
开发者指导
==========

欢迎访问protocol buffers开发者文档，protocol buffers是一个独立于语言、平台，且可拓展的自动序列化结构数据的机制。可用于通信协议、数据存储等等。

本文档旨在帮助那些希望在自己的应用程序中使用protocol buffers的Java、C++、或者Python开发者们。
概述部分介绍了protocol buffers并且说明了开始前的准备工作——您可以跟着[指引]()来学习，或者更深入的研究[protocol buffer编码机制]()。API[参考文档]()也提供了对三种编程语言的支持以及.proto文件书写的[语言]()和[风格指导]()。

什么是protocol buffers？
----------

Protocol buffers是用于序列化结构数据的自动化机制，灵活而高效——对比XML，它更小、更快、更简单。只需要定义一次数据结构，就可以使用protocol buffers生成的代码轻松从各种数据流中读写结构化的数据，甚至不需要在重新部署程序的情况下更新数据结构。

Protocol buffers如何工作？
----------

通过在`.proto`文件定义protocol buffer消息类型来指定开发者希望序列化数据结构的方式。每个protocol buffer消息都包含一系列的键值对。下面是一个.proto文件的一个非常简单的例子，该文件定义了一个人的信息：

    message Person {
      required string name = 1;
      required int32 id = 2;
      optional string email = 3;
    
      enum PhoneType {
    	MOBILE = 0;
    	HOME = 1;
    	WORK = 2;
      }
    
      message PhoneNumber {
    	required string number = 1;
    	optional PhoneType type = 2 [default = HOME];
      }
    
      repeated PhoneNumber phone = 4;
    }

如上所述，消息格式非常简单——每个消息包含有一个或多个唯一的字段，每个字段都包括一个键和一个值，值类型可以是数值（整数或者浮点数），布尔类型，字符串类型，字节或者其它任何protocol buffer消息类型。可以分层次地结构化数据。我们可以指定字段为可选型，必需型，重复型三种。关于如何书写`.proto`文件，可以在[Protocol buffer语言指导]()中找到更多帮助信息。

定义了消息之后，通过protocol buffer编译器生成应用程序语言的数据访问类。这些类提供了对每个字段（像name()和set_name()）以及方法来序列化/解析整个结构的存取器。——举例来说，如果选择C++语言来运行编译器编译上面的例子将会生成一个`Person`类。程序代码可以这么来写：

    Person person;
    person.set_name("John Doe");
    person.set_id(1234);
    person.set_email("jdoe@example.com");
    fstream output("myfile", ios::out | ios::binary);
    person.SerializeToOstream(&output);

接着就可以再从中读出内容：
    
    fstream input("myfile", ios::in | ios::binary);
    Person person;
    person.ParseFromIstream(&input);
    cout << "Name: " << person.name() << endl;
    cout << "E-mail: " << person.email() << endl;

在不影响“向后兼容性”的前提下能够向消息中添加新的字段；原有的二进制数据在解析的时候会忽略新字段。所以如果使用protocol buffer来作为通信协议数据格式的话，就无须担心破坏已有代码从而对协议进行拓展。

在[API Reference section]()中有完整的protocol buffer代码生成参考。在[Protocol Buffer Encoding]()中有更多有关protocol buffer消息编码的内容。

为什么不用XML？
----------

Protocol buffer在序列化结构数据上比XML有许多优点：  

- 更简单
- 3到10倍小
- 20到100倍快
- 歧义更少
- 生成的数据存取类更用于编程

举个例子，假如我们要创建一个人的对象，包括`name`和`email`两个属性。在XML中需要这么写：

    <person>
    	<name>John Doe</name>
    	<email>jdoe@example.com</email>
    </person>

对应的protocol buffer消息（按照protocol buffer文本格式）这么写：

    # Textual representation of a protocol buffer.
    # This is *not* the binary format used on the wire.
    person {
      name: "John Doe"
      email: "jdoe@example.com"
    }

当上面这条消息编码成protocol buffer二进制格式时（上面这条消息只是为了可读性从而这么写），就只有大概28字节大小，解析用时大概100-200纳秒。而同样由XML来做的话，则需要最少69字节（还是在不算空格的情况下），并且需要5000-10000纳秒来解析。

同样的，操作protocol buffer也更容易：

    cout << "Name: " << person.name() << endl;
    cout << "E-mail: " << person.email() << endl;

而使用XML则需要这么写：

      cout << "Name: "
       << person.getElementsByTagName("name")->item(0)->innerText()
       << endl;
      cout << "E-mail: "
       << person.getElementsByTagName("email")->item(0)->innerText()
       << endl;

然而，protocol buffers也并非总是比XML更好的解决办法——比如说，protocol buffers无法对一个基于标记文本的文档建模（如HTML）， 因为很难在protocol buffer代码中插入其它结构。除此之外，XML是便于人类阅读和编辑的；protocol buffers的原始格式（未编译相应的`.proto`文件前）并不是容易读写的。另外,XML在某种程度上还具有自我解释性，而protocol buffer只有在定义了对应的消息（.proto文件）才具有可读性。

听起来很不错，怎么开始？
----------
[下载安装包]()——安装包包括了Java、Python、和C++ protocol buffer编译器的完整的源代码，以及用于I/O和测试的类。参考README来构建和安装编译器。

完成了上面的一切准备工作，请尝试依照所选编程语言的[tutorial]()进行学习，它将指引你如何使用protocol buffers来完成一个简单的应用程序示例。

proto3介绍
----------
最新的Version3[发行版]()介绍了一个新的语言版本——Protocol Buffers Version 3（也被简称为proto3），还介绍了proto2的一些新特性。Proto3简化了protocol buffer语言：最新发行版可以生成Java、C++、Python、Java Lite、Ruby、JavaScript、Object-C和C#的protocol buffer代码。使用最新的Go语言编译插件，还可以生成Go的proto3代码，可以从[golang/protobuf]()这个仓库中找到相应内容。更多的语言支持也已提上开发日程。
